-----[header]-----
Kotlin Entity Class Generation

Expectations can be updated with:
$ ./tools/sigh updateCodegenUnitTests
-----[end_header]-----

-----[name]-----
generates entity with a public constructor
-----[input]-----
particle T
  h1: reads Thing {num: Number}
-----[results]-----

    @Suppress("UNCHECKED_CAST")
    class Thing(
        num: Double = 0.0,
        entityId: String? = null,
        creationTimestamp: Long = arcs.core.data.RawEntity.UNINITIALIZED_TIMESTAMP,
        expirationTimestamp: Long = arcs.core.data.RawEntity.UNINITIALIZED_TIMESTAMP
    ) : arcs.sdk.EntityBase("Thing", SCHEMA, entityId, creationTimestamp, expirationTimestamp, false) {
        
        var num: Double
            get() = super.getSingletonValue("num") as Double? ?: 0.0
            private set(_value) = super.setSingletonValue("num", _value)
        
        init {
            this.num = num
        }
        
        /**
         * Use this method to create a new, distinctly identified copy of the entity.
         * Storing the copy will result in a new copy of the data being stored.
         */
        fun copy(num: Double = this.num) = Thing(num = num)

        /**
         * Use this method to create a new version of an existing entity.
         * Storing the mutation will overwrite the existing entity in the set, if it exists.
         */
        fun mutate(num: Double = this.num) = Thing(
            num = num,
            entityId = entityId,
            creationTimestamp = creationTimestamp,
            expirationTimestamp = expirationTimestamp
        )
        
        companion object : arcs.sdk.EntitySpec<Thing> {
            
            override val SCHEMA = arcs.core.data.Schema(
                setOf(arcs.core.data.SchemaName("Thing")),
                arcs.core.data.SchemaFields(
                    singletons = mapOf("num" to arcs.core.data.FieldType.Number),
                    collections = emptyMap()
                ),
                "66ab3cd8dbc1462e9bcfba539dfa5c852558ad64",
                refinementExpression = true.asExpr(),
                queryExpression = true.asExpr()
            )

            private val nestedEntitySpecs: Map<String, arcs.sdk.EntitySpec<out arcs.sdk.Entity>> =
                emptyMap()

            init {
                arcs.core.data.SchemaRegistry.register(SCHEMA)
            }
            
            override fun deserialize(data: arcs.core.data.RawEntity) = Thing().apply {
                deserialize(data, nestedEntitySpecs)
            }
        }
    }
-----[end]-----

-----[name]-----
generates entity for WASM
-----[opts]-----
{"wasm":true}
-----[input]-----
particle T
  h1: reads Thing {num: Number}
-----[results]-----

    @Suppress("UNCHECKED_CAST")
    class Thing(num: Double = 0.0) : WasmEntity {
        
        var num = num
            get() = field
            private set(_value) {
                field = _value
            }
        
        override var entityId = ""
        
        fun copy(num: Double = this.num) = Thing(num = num)

        
        
        fun reset() {
            num = 0.0
        }

        override fun encodeEntity(): NullTermByteArray {
            val encoder = StringEncoder()
            encoder.encode("", entityId)
            num.let { encoder.encode("num:N", num) }
            return encoder.toNullTermByteArray()
        }

        override fun toString() =
            "Thing(num = $num)"

        companion object : WasmEntitySpec<Thing> {
            
            
            override fun decode(encoded: ByteArray): Thing? {
                if (encoded.isEmpty()) return null

                val decoder = StringDecoder(encoded)
                val entityId = decoder.decodeText()
                decoder.validate("|")
                
                var num = 0.0
                var i = 0
                while (i < 1 && !decoder.done()) {
                    val _name = decoder.upTo(':').toUtf8String()
                    when (_name) {
                        "num" -> {
                        decoder.validate("N")
                        num = decoder.decodeNum()
                    }
                        else -> {
                            // Ignore unknown fields until type slicing is fully implemented.
                            when (decoder.chomp(1).toUtf8String()) {
                                "T", "U" -> decoder.decodeText()
                                "N" -> decoder.decodeNum()
                                "B" -> decoder.decodeBool()
                            }
                            i--
                        }
                    }
                    decoder.validate("|")
                    i++
                }
                val _rtn = Thing().copy(
                    num = num
                )
               _rtn.entityId = entityId
                return _rtn
            }
        }
    }
-----[end]-----

-----[name]-----
generates variable entity with private constructor
-----[input]-----
particle T
  h1: reads ~a with {num: Number}
-----[results]-----

    @Suppress("UNCHECKED_CAST")
    class T_H1 private constructor(
        num: Double = 0.0,
        entityId: String? = null,
        creationTimestamp: Long = arcs.core.data.RawEntity.UNINITIALIZED_TIMESTAMP,
        expirationTimestamp: Long = arcs.core.data.RawEntity.UNINITIALIZED_TIMESTAMP
    ) : arcs.core.entity.VariableEntityBase(
        "T_H1",
        SCHEMA,
        entityId,
        creationTimestamp,
        expirationTimestamp,
        false
    ) {
        
        var num: Double
            get() = super.getSingletonValue("num") as Double? ?: 0.0
            private set(_value) = super.setSingletonValue("num", _value)
        
        init {
            this.num = num
        }
        
        /**
         * Use this method to create a new, distinctly identified copy of the entity.
         * Storing the copy will result in a new copy of the data being stored.
         */
        fun copy(num: Double = this.num) = T_H1(num = num)
            .also { this.copyLatentDataInto(it) }

        /**
         * Use this method to create a new version of an existing entity.
         * Storing the mutation will overwrite the existing entity in the set, if it exists.
         */
        fun mutate(num: Double = this.num) = T_H1(
            num = num,
            entityId = entityId,
            creationTimestamp = creationTimestamp,
            expirationTimestamp = expirationTimestamp
        ).also { this.copyLatentDataInto(it) }
        
        companion object : arcs.sdk.EntitySpec<T_H1> {
            
            override val SCHEMA = arcs.core.data.Schema(
                setOf(),
                arcs.core.data.SchemaFields(
                    singletons = mapOf("num" to arcs.core.data.FieldType.Number),
                    collections = emptyMap()
                ),
                "1032e45209f910286cfb898c43a1c3ca7d07aea6",
                refinementExpression = true.asExpr(),
                queryExpression = true.asExpr()
            )

            private val nestedEntitySpecs: Map<String, arcs.sdk.EntitySpec<out arcs.sdk.Entity>> =
                emptyMap()

            init {
                arcs.core.data.SchemaRegistry.register(SCHEMA)
            }
            
            override fun deserialize(data: arcs.core.data.RawEntity) = T_H1().apply {
                deserialize(data, nestedEntitySpecs)
            }
        }
    }
-----[end]-----

-----[name]-----
generates private constructor for external schema
-----[input]-----
external schema Package
particle T
  h1: reads Thing {apppackage: &Package}
-----[results]-----

    @Suppress("UNCHECKED_CAST")
    class Package(
        entityId: String? = null,
        creationTimestamp: Long = arcs.core.data.RawEntity.UNINITIALIZED_TIMESTAMP,
        expirationTimestamp: Long = arcs.core.data.RawEntity.UNINITIALIZED_TIMESTAMP
    ) : arcs.sdk.EntityBase("Package", SCHEMA, entityId, creationTimestamp, expirationTimestamp, false) {
        
        /**
         * Use this method to create a new, distinctly identified copy of the entity.
         * Storing the copy will result in a new copy of the data being stored.
         */
        fun copy() = Package()

        /**
         * Use this method to create a new version of an existing entity.
         * Storing the mutation will overwrite the existing entity in the set, if it exists.
         */
        fun mutate() = Package(
            entityId = entityId,
            creationTimestamp = creationTimestamp,
            expirationTimestamp = expirationTimestamp
        )
        
        companion object : arcs.sdk.EntitySpec<Package> {
            
            override val SCHEMA = arcs.core.data.Schema(
                setOf(arcs.core.data.SchemaName("Package")),
                arcs.core.data.SchemaFields(
                    singletons = emptyMap(),
                    collections = emptyMap()
                ),
                "e66546dddeeeeb244d5cefb50aec907475ebf424",
                refinementExpression = true.asExpr(),
                queryExpression = true.asExpr()
            )

            private val nestedEntitySpecs: Map<String, arcs.sdk.EntitySpec<out arcs.sdk.Entity>> =
                emptyMap()

            init {
                arcs.core.data.SchemaRegistry.register(SCHEMA)
            }
            
            override fun deserialize(data: arcs.core.data.RawEntity) = Package().apply {
                deserialize(data, nestedEntitySpecs)
            }
        }
    }
-----[next]-----

    @Suppress("UNCHECKED_CAST")
    class Thing(
        apppackage: arcs.sdk.Reference<Package>? = null,
        entityId: String? = null,
        creationTimestamp: Long = arcs.core.data.RawEntity.UNINITIALIZED_TIMESTAMP,
        expirationTimestamp: Long = arcs.core.data.RawEntity.UNINITIALIZED_TIMESTAMP
    ) : arcs.sdk.EntityBase("Thing", SCHEMA, entityId, creationTimestamp, expirationTimestamp, false) {
        
        var apppackage: arcs.sdk.Reference<Package>?
            get() = super.getSingletonValue("apppackage") as arcs.sdk.Reference<Package>?
            private set(_value) = super.setSingletonValue("apppackage", _value)
        
        init {
            this.apppackage = apppackage
        }
        
        /**
         * Use this method to create a new, distinctly identified copy of the entity.
         * Storing the copy will result in a new copy of the data being stored.
         */
        fun copy(apppackage: arcs.sdk.Reference<Package>? = this.apppackage) = Thing(apppackage = apppackage)

        /**
         * Use this method to create a new version of an existing entity.
         * Storing the mutation will overwrite the existing entity in the set, if it exists.
         */
        fun mutate(apppackage: arcs.sdk.Reference<Package>? = this.apppackage) = Thing(
            apppackage = apppackage,
            entityId = entityId,
            creationTimestamp = creationTimestamp,
            expirationTimestamp = expirationTimestamp
        )
        
        companion object : arcs.sdk.EntitySpec<Thing> {
            
            override val SCHEMA = arcs.core.data.Schema(
                setOf(arcs.core.data.SchemaName("Thing")),
                arcs.core.data.SchemaFields(
                    singletons = mapOf(
                        "apppackage" to arcs.core.data.FieldType.EntityRef("e66546dddeeeeb244d5cefb50aec907475ebf424")
                    ),
                    collections = emptyMap()
                ),
                "ab9592e35fddd0c0833b05289b88ddf4fe41958c",
                refinementExpression = true.asExpr(),
                queryExpression = true.asExpr()
            )

            private val nestedEntitySpecs: Map<String, arcs.sdk.EntitySpec<out arcs.sdk.Entity>> =
                mapOf("e66546dddeeeeb244d5cefb50aec907475ebf424" to Package)

            init {
                arcs.core.data.SchemaRegistry.register(SCHEMA)
            }
            
            override fun deserialize(data: arcs.core.data.RawEntity) = Thing().apply {
                deserialize(data, nestedEntitySpecs)
            }
        }
    }
-----[end]-----

-----[name]-----
generates private constructor for external reference
-----[input]-----
particle T
  h1: reads Thing {apppackage: external &Packager}
-----[results]-----

    @Suppress("UNCHECKED_CAST")
    class Packager(
        entityId: String? = null,
        creationTimestamp: Long = arcs.core.data.RawEntity.UNINITIALIZED_TIMESTAMP,
        expirationTimestamp: Long = arcs.core.data.RawEntity.UNINITIALIZED_TIMESTAMP
    ) : arcs.sdk.EntityBase("Packager", SCHEMA, entityId, creationTimestamp, expirationTimestamp, false) {
        
        /**
         * Use this method to create a new, distinctly identified copy of the entity.
         * Storing the copy will result in a new copy of the data being stored.
         */
        fun copy() = Packager()

        /**
         * Use this method to create a new version of an existing entity.
         * Storing the mutation will overwrite the existing entity in the set, if it exists.
         */
        fun mutate() = Packager(
            entityId = entityId,
            creationTimestamp = creationTimestamp,
            expirationTimestamp = expirationTimestamp
        )
        
        companion object : arcs.sdk.EntitySpec<Packager> {
            
            override val SCHEMA = arcs.core.data.Schema(
                setOf(arcs.core.data.SchemaName("Packager")),
                arcs.core.data.SchemaFields(
                    singletons = emptyMap(),
                    collections = emptyMap()
                ),
                "2aec5c62cb7c749b1a9e9b7a63d7eec057507c09",
                refinementExpression = true.asExpr(),
                queryExpression = true.asExpr()
            )

            private val nestedEntitySpecs: Map<String, arcs.sdk.EntitySpec<out arcs.sdk.Entity>> =
                emptyMap()

            init {
                arcs.core.data.SchemaRegistry.register(SCHEMA)
            }
            
            override fun deserialize(data: arcs.core.data.RawEntity) = Packager().apply {
                deserialize(data, nestedEntitySpecs)
            }
        }
    }
-----[next]-----

    @Suppress("UNCHECKED_CAST")
    class Thing(
        apppackage: arcs.sdk.Reference<Packager>? = null,
        entityId: String? = null,
        creationTimestamp: Long = arcs.core.data.RawEntity.UNINITIALIZED_TIMESTAMP,
        expirationTimestamp: Long = arcs.core.data.RawEntity.UNINITIALIZED_TIMESTAMP
    ) : arcs.sdk.EntityBase("Thing", SCHEMA, entityId, creationTimestamp, expirationTimestamp, false) {
        
        var apppackage: arcs.sdk.Reference<Packager>?
            get() = super.getSingletonValue("apppackage") as arcs.sdk.Reference<Packager>?
            private set(_value) = super.setSingletonValue("apppackage", _value)
        
        init {
            this.apppackage = apppackage
        }
        
        /**
         * Use this method to create a new, distinctly identified copy of the entity.
         * Storing the copy will result in a new copy of the data being stored.
         */
        fun copy(apppackage: arcs.sdk.Reference<Packager>? = this.apppackage) = Thing(apppackage = apppackage)

        /**
         * Use this method to create a new version of an existing entity.
         * Storing the mutation will overwrite the existing entity in the set, if it exists.
         */
        fun mutate(apppackage: arcs.sdk.Reference<Packager>? = this.apppackage) = Thing(
            apppackage = apppackage,
            entityId = entityId,
            creationTimestamp = creationTimestamp,
            expirationTimestamp = expirationTimestamp
        )
        
        companion object : arcs.sdk.EntitySpec<Thing> {
            
            override val SCHEMA = arcs.core.data.Schema(
                setOf(arcs.core.data.SchemaName("Thing")),
                arcs.core.data.SchemaFields(
                    singletons = mapOf(
                        "apppackage" to arcs.core.data.FieldType.EntityRef("2aec5c62cb7c749b1a9e9b7a63d7eec057507c09")
                    ),
                    collections = emptyMap()
                ),
                "ae1e9a821f3b8b4c160b21f693587e231c494ca5",
                refinementExpression = true.asExpr(),
                queryExpression = true.asExpr()
            )

            private val nestedEntitySpecs: Map<String, arcs.sdk.EntitySpec<out arcs.sdk.Entity>> =
                mapOf("2aec5c62cb7c749b1a9e9b7a63d7eec057507c09" to Packager)

            init {
                arcs.core.data.SchemaRegistry.register(SCHEMA)
            }
            
            override fun deserialize(data: arcs.core.data.RawEntity) = Thing().apply {
                deserialize(data, nestedEntitySpecs)
            }
        }
    }
-----[end]-----
